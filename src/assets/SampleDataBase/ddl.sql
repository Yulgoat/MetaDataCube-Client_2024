--
-- Initial settings
--

DROP SCHEMA public CASCADE;
CREATE SCHEMA public;
GRANT ALL ON SCHEMA public TO postgres;
GRANT ALL ON SCHEMA public TO public;

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;
SET log_statement = 'all';

SET default_tablespace = '';

SET default_table_access_method = heap;

ALTER SCHEMA public OWNER TO photocube;

-- ==================================== ENTITIES ====================================

------------------------------------------------------------------------- CubeObjects
CREATE TABLE public.medias (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    file_uri text NOT NULL UNIQUE,
    file_type integer NOT NULL,
    thumbnail_uri text
);

------------------------------------------------------------------------- Tag Types
CREATE TABLE public.tag_types (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    description text NOT NULL
);

------------------------------------------------------------------------- TagSets
CREATE TABLE public.tagsets (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name text NOT NULL UNIQUE,
    tagtype_id integer NOT NULL
);

------------------------------------------------------------------------- Tags
CREATE TABLE public.tags (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    tagtype_id integer NOT NULL,
    tagset_id integer NOT NULL
);

------------------------------------------------------------------------- Alphanumerical Tags
CREATE TABLE public.alphanumerical_tags (
    id integer PRIMARY KEY,
    name text NOT NULL,
    tagset_id integer NOT NULL,
    UNIQUE (name, tagset_id)
);

------------------------------------------------------------------------- Timestamp Tags
CREATE TABLE public.timestamp_tags (
    id integer PRIMARY KEY,
    name timestamp without time zone NOT NULL,
    tagset_id integer NOT NULL,
    UNIQUE (name, tagset_id)
);

------------------------------------------------------------------------- Time Tags
CREATE TABLE public.time_tags (
    id integer PRIMARY KEY,
    name time without time zone NOT NULL,
    tagset_id integer NOT NULL,
    UNIQUE (name, tagset_id)
);

------------------------------------------------------------------------- Date Tags
CREATE TABLE public.date_tags (
    id integer PRIMARY KEY,
    name date NOT NULL,
    tagset_id integer NOT NULL,
    UNIQUE (name, tagset_id)
);

------------------------------------------------------------------------- Numerical Tags
CREATE TABLE public.numerical_tags (
    id integer PRIMARY KEY,
    name integer NOT NULL,
    tagset_id integer NOT NULL,
    UNIQUE (name, tagset_id)
);

------------------------------------------------------------------------- Object-Tag Relations (N-N relation between tags and medias)
CREATE TABLE public.taggings (
    object_id integer NOT NULL,
    tag_id integer NOT NULL,
    PRIMARY KEY (object_id, tag_id)
);

------------------------------------------------------------------------- Hierarchies
CREATE TABLE public.hierarchies (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name text NOT NULL,
    tagset_id integer NOT NULL,
    rootnode_id integer NULL,
    UNIQUE (name, tagset_id)
);

------------------------------------------------------------------------- Nodes
CREATE TABLE public.nodes (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    tag_id integer NOT NULL,
    hierarchy_id integer NOT NULL,
    parentnode_id integer NULL
    -- UNIQUE(tag_id, hierarchy_id)
);


-- ==================================== INDEXES ====================================

------------------------------------------------------------------------- Tags
CREATE INDEX "IX_tags_tagset_id" ON public.tags USING btree (tagset_id);

CREATE INDEX "IX_tags_tagtype_id" ON public.tags USING btree (tagtype_id);


------------------------------------------------------------------------- Object-Tag Relations
CREATE INDEX "IX_taggings_tag_id" ON public.taggings USING btree (tag_id);


------------------------------------------------------------------------- Hierarchies
CREATE INDEX "IX_hierarchies_tagset_id" ON public.hierarchies USING btree (tagset_id);


------------------------------------------------------------------------- Nodes
CREATE INDEX "IX_nodes_hierarchy_id" ON public.nodes USING btree (hierarchy_id);

CREATE INDEX "IX_nodes_parentnode_id" ON public.nodes USING btree (parentnode_id);

CREATE INDEX "IX_nodes_tag_id" ON public.nodes USING btree (tag_id);


-- ==================================== FOREIGN KEYS ====================================

------------------------------------------------------------------------- Tagsets
ALTER TABLE ONLY public.tagsets
    ADD CONSTRAINT "FK_tagsets_tag_types_tagtype_id" FOREIGN KEY (tagtype_id) REFERENCES public.tag_types(id) ON DELETE RESTRICT;


------------------------------------------------------------------------- Tags
ALTER TABLE ONLY public.tags
    ADD CONSTRAINT "FK_tags_tag_types_tagtype_id" FOREIGN KEY (tagtype_id) REFERENCES public.tag_types(id) ON DELETE RESTRICT;

ALTER TABLE ONLY public.tags
    ADD CONSTRAINT "FK_tags_tagsets_tagset_id" FOREIGN KEY (tagset_id) REFERENCES public.tagsets(id) ON DELETE RESTRICT;



ALTER TABLE ONLY public.alphanumerical_tags
    ADD CONSTRAINT "FK_alphanumerical_tags_tags_id" FOREIGN KEY (id) REFERENCES public.tags(id) ON DELETE CASCADE;

ALTER TABLE ONLY public.alphanumerical_tags
    ADD CONSTRAINT "FK_alphanumerical_tags_tagsets_tagset_id" FOREIGN KEY (tagset_id) REFERENCES public.tagsets(id) ON DELETE RESTRICT;



ALTER TABLE ONLY public.timestamp_tags
    ADD CONSTRAINT "FK_timestamp_tags_tags_id" FOREIGN KEY (id) REFERENCES public.tags(id) ON DELETE CASCADE;

ALTER TABLE ONLY public.timestamp_tags
    ADD CONSTRAINT "FK_timestamp_tags_tagsets_tagset_id" FOREIGN KEY (tagset_id) REFERENCES public.tagsets(id) ON DELETE RESTRICT;



ALTER TABLE ONLY public.time_tags
    ADD CONSTRAINT "FK_time_tags_tags_id" FOREIGN KEY (id) REFERENCES public.tags(id) ON DELETE CASCADE;

ALTER TABLE ONLY public.time_tags
    ADD CONSTRAINT "FK_time_tags_tagsets_tagset_id" FOREIGN KEY (tagset_id) REFERENCES public.tagsets(id) ON DELETE RESTRICT;



ALTER TABLE ONLY public.date_tags
    ADD CONSTRAINT "FK_date_tags_tags_id" FOREIGN KEY (id) REFERENCES public.tags(id) ON DELETE CASCADE;

ALTER TABLE ONLY public.date_tags
    ADD CONSTRAINT "FK_date_tags_tagsets_tagset_id" FOREIGN KEY (tagset_id) REFERENCES public.tagsets(id) ON DELETE RESTRICT;



ALTER TABLE ONLY public.numerical_tags
    ADD CONSTRAINT "FK_numerical_tags_tags_id" FOREIGN KEY (id) REFERENCES public.tags(id) ON DELETE CASCADE;

ALTER TABLE ONLY public.numerical_tags
    ADD CONSTRAINT "FK_numerical_tags_tagsets_tagset_id" FOREIGN KEY (tagset_id) REFERENCES public.tagsets(id) ON DELETE RESTRICT;


------------------------------------------------------------------------- Object-Tag Relations
ALTER TABLE ONLY public.taggings
    ADD CONSTRAINT "FK_taggings_medias_object_id" FOREIGN KEY (object_id) REFERENCES public.medias(id) ON DELETE CASCADE;


ALTER TABLE ONLY public.taggings
    ADD CONSTRAINT "FK_taggings_tags_tag_id" FOREIGN KEY (tag_id) REFERENCES public.tags(id) ON DELETE CASCADE;


------------------------------------------------------------------------- Hierarchies
ALTER TABLE ONLY public.hierarchies
    ADD CONSTRAINT "FK_hierarchies_tagsets_tagset_id" FOREIGN KEY (tagset_id) REFERENCES public.tagsets(id) ON DELETE RESTRICT;

ALTER TABLE ONLY public.hierarchies
    ADD CONSTRAINT "FK_hierarchies_nodes_rootnode_id" FOREIGN KEY (rootnode_id) REFERENCES public.nodes(id) ON DELETE RESTRICT;


------------------------------------------------------------------------- Nodes
ALTER TABLE ONLY public.nodes
    ADD CONSTRAINT "FK_nodes_hierarchies_hierarchy_id" FOREIGN KEY (hierarchy_id) REFERENCES public.hierarchies(id) ON DELETE RESTRICT;

ALTER TABLE ONLY public.nodes
    ADD CONSTRAINT "FK_nodes_nodes_parentnode_id" FOREIGN KEY (parentnode_id) REFERENCES public.nodes(id) ON DELETE RESTRICT;
    
ALTER TABLE ONLY public.nodes
    ADD CONSTRAINT "FK_nodes_tags_tag_id" FOREIGN KEY (tag_id) REFERENCES public.tags(id) ON DELETE CASCADE;


-- Setting up the tag types, then making the table read-only

INSERT INTO public.tag_types (description) 
VALUES 
('alphanumerical'),
('timestamp'),
('time'),
('date'),
('numerical');

REVOKE ALL ON public.tag_types FROM postgres;
REVOKE ALL ON public.tag_types FROM public;
GRANT SELECT ON public.tag_types TO postgres;
GRANT SELECT ON public.tag_types TO public;

GRANT SELECT, UPDATE, INSERT, DELETE ON ALL TABLES IN SCHEMA public TO photocube;

-- TODO: the postgres user is still able to add new types

-- Check that the type of tags correspond to the type of the tagset
CREATE OR REPLACE FUNCTION public.check_matching_tagtype()
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.tagtype_id IS DISTINCT FROM (SELECT tagtype_id FROM public.tagsets WHERE id = NEW.tagset_id)) THEN
        RAISE EXCEPTION 'Tagtype_id does not match the corresponding tagset''s tagtype_id';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_tagtype_matching
BEFORE INSERT OR UPDATE ON public.tags
FOR EACH ROW
EXECUTE FUNCTION public.check_matching_tagtype();

-- Check that the tag belongs the the tagset of the hierachy
CREATE OR REPLACE FUNCTION public.check_nodes_tagset()
RETURNS TRIGGER AS
$$
DECLARE
  tagset_id_for_hierarchy INTEGER;
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM public.tags t 
    JOIN (SELECT tagset_id FROM public.hierarchies WHERE id = NEW.hierarchy_id) h
    ON t.tagset_id = h.tagset_id
    WHERE t.id = NEW.tag_id
  ) THEN
    RAISE EXCEPTION 'The tag_id does not belong to the correct tagset_id for this hierarchy.';
  END IF;
  RETURN NEW;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER trigger_check_nodes_tagset
BEFORE INSERT OR UPDATE ON public.nodes
FOR EACH ROW
EXECUTE FUNCTION public.check_nodes_tagset();
